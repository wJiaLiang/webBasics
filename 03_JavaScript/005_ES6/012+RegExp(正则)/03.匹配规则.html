<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

        <script>
            (function(){
               var val = 'abc'.match(/.b./);
                console.log(val.length);

            })();



            (function (param) {
                // 字面量字符和元字符 就是字面的含义，比如/a/匹配a，/b/匹配b
                // (1) 点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符
                console.log( 'asb'.match(/a.b/) );      // 匹配ab中任意一个字符的情况; ['asb']

                // (2)位置字符
                // ^ 表示字符串的开始位置
                // $ 表示字符串的结束位置

                let z = /^test/.test('test,我是一个字符串,test表示要出现在开头的位置');
                console.log(z);     // true;
                let z1 = /test$/.test('test,表示test出现在结束的位置test');
                console.log(z1);    // true;
                // 从开始位置到结束位置只有test
                /^test$/.test('test') // true

            })();
            (function () {
                // (3) 选择符（|） 在正则表达式中表示“或关系” 
                // 其他的元字符还包括\\、\*、+、?、()、[]、{}
                /11|22/.test('911') // true
                
                // (4) 转义符;
                // 正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成\+。
                // 正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\

                // (5) 特殊字符
                // 正则表达式对一些不能打印的特殊字符，提供了表达方法。

            })();

            (function () {
                // 字符类

                // (6) 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。
                /[abc]/.test('apple') // true

                // (7)脱字符（^）
                /**
                如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。
                比如，[^xyz]表示除了x、y、z之外都可以匹配。
                */ 
                let s = /[^abc]/.test('hello world');   // true
                let s1 = /[^abc]/.test('bbc');          // false

                // 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。
                // 相比之下，点号作为元字符（.）是不包括换行符的。
                // 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。
                // 相比之下，点号作为元字符（.）是不包括换行符的。

                // 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

                // （8）连字符（-）
                // 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。
                /a-z/.test('b')              // false
                let s3 = /[a-z]/.test('b')   // true

                // 上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。
                // 只有当连字号用在方括号之中，才表示连续的字符序列

            })();


            (function () {
                //  预定义模式;
                /*  预定义模式指的是某些常见模式的简写方式。
                    \d 匹配0-9之间的任一数字，相当于[0-9]。
                    \D 匹配所有0-9以外的字符，相当于[^0-9]。
                    \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
                    \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
                    \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。
                    \S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。
                    \b 匹配词的边界。
                    \B 匹配非词边界，即在词的内部。
                */

            })();


            (function (param) {
                // 重复类
                // 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。
                let s4 = /lo{2}k/.test('look') // true
                let s5 = /lo{2,5}k/.test('looook') // true

            })();


            (function () {
                // 量词符
                // 量词符用来设定某个模式出现的次数。
                /*
                    ? 问号表示某个模式出现0次或1次，等同于{0, 1}。
                    * 星号表示某个模式出现0次或多次，等同于{0,}。
                    + 加号表示某个模式出现1次或多次，等同于{1,}。
                */ 
               console.log( /t?est/.test('test') );
               console.log( /t*est/.test('test') );
               console.log( /t+est/.test('test') );

            })();


            (function () {
                //  贪婪模式
                /* 上一小节的三个量词符,(? * +)默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。
                    模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。
                    如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。
                    *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
                    +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。
                */
                
                let  s = 'aaa';
                s.match(/a+?/) // ["aaa"]
                s.match(/a+?/) // ["a"]

            })();


            (function () {
                //  修饰符
                /**
                    修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。
                    修饰符可以单个使用，也可以多个一起使用。

                （1）g 修饰符
                    默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），
                    加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

                （2）i 修饰符
                    默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。

                （3）m 修饰符
                    m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），
                    ^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。
                */ 

            })();


            (function () {
                // 组匹配
                // 正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。
                //第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配fred这个词。

                /fred+/.test('fredd');      // true
                /(fred)+/.test('fredfred'); // true

             

            })();

            
            (function () {
                // 表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

                //  不会单独匹配;
                console.log('foo'.match( /(foo){1,2}/));   // ['foo','foo'];
                //  非组匹配
                console.log('foo'.match( /(?:foo){1,2}/)); // ['foo];

                console.log('abc'.match(/(?:.)b(.)/));

            })()

        
        
           
        
        </script>
</body>
</html>