<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script type="module">
    //使用export命令定义了模块的对外接口以后，
    //其他 JS 文件就可以通过import命令加载这个模块。
    //
    // 必须把script 的type  属性设置为 module;
    import {c} from './src/main.js';
    c();


    //import命令输入的变量都是只读的，因为它的本质是输入接口。
    //也就是说，不允许在加载模块的脚本里面，改写接口。


/*
    脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。

    import {a} from './xxx.js'
    a = {}; // Syntax Error : 'a' is read-only;

    import {a} from './xxx.js'
    a.foo = 'hello'; // 合法操作

 */ 

/*
    1.import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。
    
    2.import命令具有提升效果，会提升到整个模块的头部，首先执行。
        foo();
        import { foo } from 'my_module';
    上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。

    3.由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。

    4.  import { foo } from 'my_module';
        import { bar } from 'my_module';
        // 等同于
        import { foo, bar } from 'my_module';
        上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例
        目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。

 */ 








    </script>
</body>
</html>