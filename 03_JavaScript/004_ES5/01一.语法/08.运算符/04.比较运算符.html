<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script type="text/javascript">
       //比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件。
       2 > 1    // true
       //注意，比较运算符可以比较各种类型的值，不仅仅是数值
        //  == 相等
        //  === 严格相等
        //  != 不相等
        //  !== 严格不相等
        //  < 小于
        //  <= 小于或等于
        //  > 大于
        //  >= 大于或等于
//相等运算符和精确相等运算符，有自己的比较算法。其他六个比较运算符的算法如下。
// 1.如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较 Unicode 码点）。
// 2.否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）

// 字符串的比较:
// 'cat' > 'dog' // false
// 'cat' > 'catalog' // false
    //JavaScript 引擎内部首先比较首字符的 Unicode 码点，如果相等，
    //再比较第二个字符的 Unicode 码点，以此类推。


// 非字符串的比较:
/*  两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。

*/
    5 > '4' // true
    // 等同于 5 > Number('4')
    // 即 5 > 4

    true > false // true
    // 等同于 Number(true) > Number(false)
    // 即 1 > 0

    2 > true // true
    // 等同于 2 > Number(true)
    // 即 2 > 1

// 对象：
// 如果运算子是对象，会转为原始类型的值，再进行比较。    
//对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法


// 严格相等运算符
/*  简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转化成同一个类型，再用严格相等运算符进行比较。
*/

/*******************************************************************/ 
// 严格相等运算符的算法如下。

// （1）不同类型的值
//  如果两个值的类型不同，直接返回false
    1 === "1" // false
    true === "true" // false

// （2）同一类的原始类型值
    
    // 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。
    1 === 0x1   // true   十进制的1和十六进制的1;
    // NaN === NaN  // false   NaN与任何值都不相等;

// （3）同一类的复合类型值
// 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，
// 而是比较它们是否指向同一个对象。
    {} === {} // false
    [] === [] // false

// 上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false
    var v1 = {};
    var v2 = v1;
    v1 === v2 // true

// 对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。
    
//(4) undefined 和 null
    // undefined和null与自身严格相等。
    // undefined === undefined     // true
    // null === null               // true

//(5) 严格不相等运算符
// 严格相等运算符有一个对应的“严格不相等运算符”（!==），两者的运算结果正好相反。
    1!=='true'

/******************************************************************/ 
// 相等运算符:
/*
相等运算符比较相同类型的数据时，与严格相等运算符完全一样。
比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下。
*/ 
// （1）原始类型的数据会转换成数值类型再进行比较:
    1==true;    // 等同于 1 === 1
    0 == false  // true
    'true' == true  // false
    // 等同于 Number('true') === Number(true)
    // 等同于 NaN === 1

    '' == 0 // true
    // 等同于 Number('') === 0
    // 等同于 0 === 0

    '' == 0 // true
    // 等同于 Number('') === 0
    // 等同于 0 === 0

// （2）对象与原始类型值比较
    // 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。


// （3）undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。
    //  false == null       // false
    //  false == undefined  // false
    //  0 == null           // false
    //  0 == undefined      // false
    //  undefined == null   // true


// （4）相等运算符的缺点
    // 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。
    '' == '0'           // false
    false == 'false'    // false

    false == '0'        // true

    //上面这些表达式都很容易出错，因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。

// （5）不相等运算符   
    //相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。
    1 != '1' // false




    </script>
</body>
</html>