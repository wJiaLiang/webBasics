<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title> 013列表进入离开过度 </title>
        <style>
            .list-item {
                display: inline-block;
                margin-right: 10px;
              
            }
            .list-enter-active,
            .list-leave-active {
                transition: all 1s;
            }
            .list-enter-from,
            .list-leave-to {
                /* .list-leave-active for below version 2.1.8 */
                opacity: 0;
                transform: translateY(30px);
            }
            .list-move{transition:transform 1s;}

           
           
        </style>
    </head>
    <body>
        <div id="app">
            <div id="list-demo" class="demo">
                <button v-on:click="add">Add</button>
                <button v-on:click="remove">Remove</button>
                <transition-group name="list" tag="p">
                    <span
                        @click="remove"
                        v-for="item in items"
                        v-bind:key="item"
                        class="list-item"
                    >
                        {{ item }}
                    </span>
                </transition-group>
            </div>

            
        </div>
    </body>
    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
    <script src="https://unpkg.com/vue@next"></script>
    <script>
        /*
            现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。
            当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，
            而不是平滑的过渡，下个例子会解决这个问题。
        */ 
        const app = Vue.createApp({
            data() {
                return {
                    items: [1, 2, 3, 4, 5, 6, 7, 8, 9],
                    nextNum: 10,
                };
            },
            setup() {},
            // props 可以是数组或对象，用于接收来自父组件的数据
            props: [],

            // 方法;
            methods: {
                randomIndex: function () {
                    return Math.floor(Math.random() * this.items.length);
                },
                add: function () {
                    this.items.splice(this.randomIndex(), 0, this.nextNum++);
                },
                remove: function () {
                    this.items.splice(this.randomIndex(), 1);
                },

            },

        });

        app.mount("#app");
    </script>
</html>
