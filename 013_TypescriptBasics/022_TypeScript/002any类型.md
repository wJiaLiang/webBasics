
## 一、any 类型
any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。
变量类型一旦设为any，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。

TypeScript 编译时都不报错。原因就是x的类型是any，TypeScript 不对其进行类型检查。

实际开发中，any类型主要适用以下两个场合。
（1）出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为any。
（2）为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为any。

集合论的角度看，any类型可以看成是所有其他类型的全集，包含了一切可能的类型。
TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。


let a: any;
a = 'hello';
a.foo = 100; // ts编译时都不会报错，js执行时候会报错;


## 二、类型推断问题
1、如果没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是any。

2、污染问题
就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。

function add(x, y) {
    return x + y;
}
add(1, [1, 2, 3]) // ts编译时都不会报错，js执行时候会报错



let x:any = 'hello';
let y:number;
y = x; // 不报错 导致变量y被污染;
y * 123 // 不报错
y.toFixed() // 不报错
// 这时并不会报错。然后，变量y继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。


## 三、unknown 类型
unknown跟any的相似之处，在于所有类型的值都可以分配给unknown类型。

unknown类型跟any类型的不同之处在于，它不能直接使用
1、unknown类型的变量，不能直接赋值给其他类型的变量（除了any类型和unknown类型）。

2、其次，不能直接调用unknown类型变量的方法和属性。

3、再次，unknown类型变量能够进行的运算是有限的，
只能进行比较运算（运算符==、===、!=、!==、||、&&、?）、取反运算（运算符!）、typeof运算符和instanceof运算符这几种


let v:unknown = 123;
// let v1:boolean = v; // 报错

let v2:unknown = { foo: 123 };
// v2.foo  // 报错



## 四、never 类型
为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。
由于不存在任何属于“空类型”的值，所以该类型被称为never，即不可能有这样的值。

never类型的使用场景，
1、主要是在一些类型运算之中，保证类型运算的完整性，
2、不可能返回值的函数，返回值的类型就可以写成never
never类型的一个重要特点是，可以赋值给任意其他类型。

为什么never类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。
TypeScript 就相应规定，任何类型都包含了never类型。因此，never类型是任何其他类型所共有的，
TypeScript 把这种情况称为“底层类型”（bottom type）。

总之，TypeScript 有两个“顶层类型”（any和unknown），但是“底层类型”只有never唯一一个。






export {}